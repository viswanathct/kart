---
imports:
  - eka.shorthands.types.* # Provides type shorthands.
  - services # #ToDo: Think of using python style "as" keyword.

declarations: # Declarations are a way to declare shorthands.
  shared:
    scope: client, server # #Later: Think of inferring (implicit) scope, by identifying the object type through its properties.

  location:
    fields: # Properties defined under fields are accessible through the parent element. ie: lat could be accessed as location.lat.
      lat: double
      long: double

structure:
  Session:
    scope: shared # #Note: The absence of the 'id' field implies that this is a create request.
    fields:
      user: string
      password: password # The scope, client is implied for the type, password.

  Order:
    providers: [shared] # #Note: This essentially is prototypal inheritance and are recursive (multi-level).
    fields:
      Shop: when(existing, confirm("Want to discard items from $existing.name and buy from $incoming.name?", existing, incoming)) # A shop would be passed to the setter, for further action. #Note: The function would be called only when there's an existing value.
      Items:
        type: list
        filter: Items.Dish.Shop == Shop
        element:
          Dish: Dish # Only the id of the dish gets transferred, and the Server converts it back to the dish, as it knows the type.
          Customizations: filter(collect(Dish.Customizations), true).name # The collect function collects the data through a generated form.
          cost:
            scope: local
            value: Dish.unitPrice + sum(Dish.Customizations[Customizations].cost)
      subTotal: sum(Items.cost)
      taxes: reduce(Items, 0, (Items, Item, trailing => trailing += Item.Dish.taxes))
      netTotal: subTotal + deliveryCharge + Taxes
      createdAt:
        value: currentTime()
        scope: store

      deliveryCharge:
        function: case
        param: Cart.subTotal
        cases:
          param > Config.freeDeliveryMinimum: 0
          default: Config.deliveryCharge

  Server:
    type: group
    scope: server
    children:
      Config:
        fields: {} # A global state value with multiple config variables. It's not defined, in the interest of brevity.

      Profile:
        fields:
          id: Sessions.user

      shop: server.shop # #Note: This is an implicit import from configs/shop.yml.

      promo: server.promo

      Shops:
        type: Map # #Later: The notation Map<Shop> could be used, after the implementation of DSL parsing.
        element: shop
        # The id is assumed to be the mapKey. Alternatively, it could be map<shop.id, shop>.
        params: # This maps to the resource /Shops/{CustomerLocation}
          CustomerLocation: CustomerLocation # The field is required, as it isn't explicitly marked as optional.

        filter: CustomerLocation => services.isShopWithinRadius(CustomerLocation, Config.deliveryRange) # The table shop is inferred to be iterated from the element type (shop).
        limit: 100
        orderBy: shop.rating, descending

  UI:
    type: group
    scope: ui # The config is shared with all the members of the group.
    children: # Children is a property which facilitates access, but nothing more.
      CustomerLocation: location # Though the property is under the group, ui. It lives in the parent scope, as groups don't have a scope of their own.
      searchText: string

      Filters:
        children:
          # locationFilter: Shop => Shop.dit <= Config.maxDIT
          tagFilter: Shop => hasMatch(Shop.Tags, FiltersSelection.AppliedTagFilters) # #Note: The function itself, should be optimized for empty lists. Variable dependency too should be taken care of.
          # cuisineFilter: Shop => hasMatch(Shop.Tags, FiltersSelection.AppliedTagFilters)
          searchFilter: Shop => when(searchText, has(Shop.name, searchText)) # Returning 'undefined' is interpreted as not filtered. #Note: The same filters could be used on the server side too.

      Shop:
        action: SelectedShop = Shop # The default action is a touch or a click.
        route: Dishes # Route to the screen, Dishes when a shop is clicked.

      Dish:
        providers: server.Dish
        actions: # The scope of actions, is always, ui.
          addOrderItem:
            title: '+'
            sequence:
              - Order.Shop = Shop
              - Order.Items.add(Dish)
          removeOrderItem:
            children:
              matchingItem = Item => Item.Dish.id = Dish.id # #Later: The function could be automatically generated, by comparing the inline lambdas.
            title: '-'
            enabled: count(filter(Order.Items.Dish, Dish)) # When value is given for filter, other than a function, an equality check would be done.
            sequence:
              - Order.Items.remove(last(filter(Order.Items, OrderItem => OrderItem.Dish == Dish)))

      App:
        type: ui
        route: MainScreen
        nodes:
          MainScreen:
            Tabs:
              # type: tree # It's used for readability, by wrapping its elements under *nodes* properties.
              # tree: {}
              nodes:
                Home:
                  nodes:
                    CustomerLocation: services.getCurrentLocation(CustomerLocation)

                    FiltersSelection:
                      fields: # #Note: The type of the resource is inferred to be 'object' due to the existence of the property, fields.
                        Tags:
                          hasOffers:
                            type: boolean
                            value: False
                          isPureVeg:
                            type: boolean
                            value: False # #Note: The value signifies, whether the filter is applied or not.
                        AppliedTagFilters: filter(Filter.Tags, true) # #Note: The key is used for caching the function results. There is a plan to implement lazy evaluation, on functions, so that there won't be a need for explicit caching.

                    Promos: Map<promo> # This essentially is a shorthand for a map of promos, with promo[id] as its mapKey.

                    ShopSelector:
                      fields: # #ToDo: Implement an action.
                        sortOrder: dit, avgCost, rating desc
                        Shops:
                          type: List<Shop>
                          value: Shops
                          filter: cascade(Filters.tagFilter, Filters.cuisineFilter, Filters.searchFilter)
                          orderBy: sortOrder

                Explore:
                  nodes:
                    searchText:
                      value: searchText
                      handler: plugins.autoFill
                      config:
                        limit: 10

                Cart:
                  value: Order
                  scope: ui
                  fields:
                    Items: # This overlays Order.Items
                      groupBy: Item.Dish, Item.Customizations
                      fields:
                        cost: sum(Item.cost) # All fields that aren't in groupBy should be over-rode with aggregators. #Later: Default aggregators can be provided, based on the data type of the fields. The function mode for string, sum for double etc.
                        count: count()

                  actions: # The scope of actions, is always, ui.
                    addOrderItem:
                      title: '+'
                      sequence:
                        - Order.Items.add(Dish)
                    removeOrderItem:
                      children:
                        matchingItem = Item => Item.Dish.id = Dish.id # #Later: The function could be automatically generated, by comparing the inline lambdas.
                      title: '-'
                      sequence:
                        - "Order.Items.remove(last(filter(Order.Items,
                            OrderItem => OrderItem.Dish == Item.Dish && OrderItem.Customizations == Item.Customizations
                          ).Customizations)"

              Account: {}

            TabSwitcher:
                type: ui.tabSwitcher
                config:
                  tabs: App.Tabs

          Dishes:
            type: List # No UI spec is given as it would be rendered as a simple, scrollable list.
            element: Dish
            params:
              Shop: SelectedShop  # This essentially queries /Dish?Shop=<SelectedShop.id>, when the list is empty.

          Customizer: {}
