---
imports:
  - eka.shorthands.types.* # Provides type shorthands.
  - services # #ToDo: Think of using python style "as" keyword.

declarations: # Declarations are a way to declare shorthands.
  shared:
    scope: client, server # #Later: Think of inferring (implicit) scope, by identifying the object type through its properties.

  location:
    fields: # Properties defined under fields are accessible through the parent element. ie: lat could be accessed as location.lat.
      lat: double
      long: double

structure:
  Session:
    scope: shared # #Note: The absence of the 'id' field implies that this is a create request.
    fields:
      user: string
      password: password # The scope, client is implied for the type, password.

  Server:
    type: group
    scope: server
    children:
      Config:
        fields: {} # A global state value with multiple config variables. It's not defined, in the interest of brevity.

      Profile:
        fields:
          id: Sessions.user

      shop: server.shop # #Note: This is an implicit import from configs/shop.yml.

      promo: server.promo

      Shops:
        type: Map # #Later: The notation Map<Shop> could be used, after the implementation of DSL parsing.
        element: shop
        # The id is assumed to be the mapKey. Alternatively, it could be map<shop.id, shop>.
        params: # This maps to the resource /Shops/{CustomerLocation}
          CustomerLocation: CustomerLocation # The field is required, as it isn't explicitly marked as optional.

        filter: CustomerLocation => services.isShopWithinRadius(CustomerLocation, Config.deliveryRange) # The table shop is inferred to be iterated from the element type (shop).
        limit: 100
        orderBy: shop.rating, descending

  UI:
    type: group
    scope: ui # The config is shared with all the members of the group.
    children: # Children is a property which facilitates access, but nothing more.
      CustomerLocation: location # Though the property is under the group, ui. It lives in the parent scope, as groups don't have a scope of their own.
      searchText: string

      Filters:
        children:
          # locationFilter: Shop => Shop[dit] <= Config[maxDIT] #
          tagFilter: Shop => hasMatch(Shop.Tags, FiltersSelection.AppliedTagFilters) # #Note: The function itself, should be optimized for empty lists. Variable dependency too should be taken care of.
          # cuisineFilter: Shop => hasMatch(Shop.Tags, FiltersSelection.AppliedTagFilters)
          searchFilter: Shop => when(searchText, has(Shop[name], searchText)) # Returning 'undefined' is interpreted as not filtered. #Note: The same filters could be used on the server side too.

      Shop:
        action: SelectedShop = Shop # The default action is a touch or a click.

      Dish:
        providers: server.Dish
        actions: # The scope of actions, is always, ui.
          addToCart:
            title: '+'
            sequence:
              - Cart[Shop] = Shops[id]
              - customize()
              - count = count + 1
          removeFromCart:
            title: '-'
            enabled: count > 0
            sequence:
              - count = count - 1
              - addedTime = null

      App:
        type: ui
        nodes:
          MainScreen:
            Tabs:
              # type: tree # It's used for readability, by wrapping its elements under *nodes* properties.
              # tree: {}
              nodes:
                Home:
                  nodes:
                    CustomerLocation: services.getCurrentLocation(CustomerLocation)

                    FiltersSelection:
                      fields: # #Note: The type of the resource is inferred to be 'object' due to the existence of the property, fields.
                        Tags:
                          hasOffers:
                            type: boolean
                            value: False
                          isPureVeg:
                            type: boolean
                            value: False # #Note: The value signifies, whether the filter is applied or not.
                        AppliedTagFilters: filter(Filter.Tags, true) # #Note: The key is used for caching the function results. There is a plan to implement lazy evaluation, on functions, so that there won't be a need for explicit caching.

                    Promos: Map<promo> # This essentially is a shorthand for a map of promos, with promo[id] as its mapKey.

                    ShopSelector:
                      fields: # #ToDo: Implement an action.
                        sortOrder: [dit, avgCost, rating]
                        Shops:
                          type: List<Shop>
                          value: Shops
                          filter: cascade(Filters.tagFilter, Filters.cuisineFilter, Filters.searchFilter)
                          sortOrder: sortOrder

                Explore:
                  nodes:
                    searchText:
                      value: searchText
                      handler: plugins.autoFill
                      config:
                        limit: 10

                Cart:
                  providers: [shared] # #Note: This essentially is prototypal inheritance and are recursive (multi-level).
                  fields:
                    Shop: when(existing, confirm("Want to discard items from $existing[name] and buy from $incoming[name]?", existing, incoming)) # A shop would be passed to the setter, for further action. #Note: The function would be called only when there's an existing value.
                    id: Shop[id]
                    title:
                      value: Shop[name]
                      scope: ui
                    Dishes: # #ToDo: Figure out the way to mimic the required behavior of representing articles with different customizations as different items.
                      type: list
                      elementType: Dish
                      orderBy: Dish.addedTime
                      filter: Dish[shop] == Cart[Shop][id]
                    subTotal:
                      map(Dishes, Dish => Dish.count * Dish.unitPrice)
                      # SELECT Dish.count * Dish.unitPrice from Dishes
                      # sum(Dishes.count * Dishes.unitPrice) # In which the Dishes.cost is an enumerator (like that of Python's Pandas).
                    taxes: reduce(Dishes, 0, (Dish, trailing => trailing += Dish.taxes))
                    netTotal: subTotal + deliveryCharge + Taxes
                    createdAt:
                      value: currentTime()
                      scope: store

                    deliveryCharge:
                      function: case
                      param: Cart[subTotal]
                      cases:
                        param > Config[freeDeliveryMinimum]: 0
                        default: Config[deliveryCharge]

              Account: {}

            TabSwitcher:
                type: ui.tabSwitcher
                config:
                  tabs: App.Tabs

          Dishes:
            type: List # No UI spec is given as it would be rendered as a simple, scrollable list.
            element: Dish
            params:
              shop: SelectedShop.id # This essentially queries /Dish?shop=<x>, when the list is empty.
