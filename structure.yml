---
# Domain Objects
imports:
  - eka.shorthands.types.* # Provides type shorthands.
  - services # #ToDo: Think of using python style "as" keyword.

declarations: # Declarations are a way to declare shorthands.
  shared:
    scope: client, server # #Later: Think of inferring (implicit) scope, by identifying the object type through its properties.

  location:
    fields: # Properties defined under fields are accessible through the parent element. ie: lat could be accessed as location.lat.
      lat: double
      long: double

structure:
  Session:
    scope: shared # #Note: The absence of the 'id' field implies that this is a create request.
    fields:
      user: string
      password: password # The scope, client is implied for the type, password.

  Server:
    type: group
    scope: server
    children:
      Config:
        fields: {} # A global state value with multiple config variables. It's not defined, in the interest of brevity.

      Profile:
        fields:
          id: Sessions.user

      Shop: # The same structure is used to define, both the data and the UI schemas.
        type: object # id is assumed to be the param for read requests.
        fields:
          id: integer
          nam√üe: string
          address: string
          dit: Duration
          rating: double
          avgCost: double
          Tags: List<string>
          Cuisines: List<string>
          Offers: List<Offer> # #ToDo: Define an offer object, which would allow a free dessert of values less than fifty rupees, for orders of value greater than 150.
        error: shop-fetch-failed

      Shops:
        type: Map # #Later: The notation Map<Shop> could be used, after the implementation of DSL parsing.
        element: shop
        # The id is assumed to be the mapKey. Alternatively, it could be map<shop.id, shop>.
        params: # This maps to the resource /Shops/{CustomerLocation}
          CustomerLocation: CustomerLocation #ToDo: Figure out the default representation of complex objects in queries. They could be inline JSON or multiple query parameters. ie: The representation of this field could be ?CustomerLocation={x,y} or ?lat=x&long=y.
          # Note: When all expect one fields are optional, the expected field becomes the default.
          searchText:
            value: searchText
            optional: true

      Article:
        fields:
          id: integer
          shop: [integer] # The value could also be a list of providers.
          classification: string
          count: integer
          unitPrice: double
          taxPercentage: 0.05 # This is interpreted as hard-coded value, as it doesn't match any other variable.
          cost:
            value: count * unitPrice
            scope: local
          taxes:
            value: cost * taxPercentage
            scope: local
          addedTime: when(existing == null, currentTime())
          Customizations:
              customization_1:
                name: string
                cost: 10
        actions: # The scope of actions, is always, ui.
          addToCart:
            title: '+'
            actions:
              - Cart[Shop] = Shops[id]
              - customize()
              - count = count + 1
          removeFromCart:
            title: '-'
            enabled: count > 0
            actions:
              - count = count - 1
              - addedTime = null

      Articles:
        params:
          shop: Shop.id

  UI:
    type: group
    scope: ui # The config is shared with all the members of the group.
    children: # Children is a property which facilitates access, but nothing more.
      CustomerLocation: location # Though the property is under the group, ui. It lives in the parent scope, as groups don't have a scope of their own.
      searchText: string

      Filters:
        children:
          # locationFilter: Shop => Shop[dit] <= Config[maxDIT] #
          tagFilter: Shop => hasMatch(Shop.Tags, FiltersSelection.AppliedTagFilters) # #Note: The function itself, should be optimized for empty lists.
          # cuisineFilter: Shop => hasMatch(Shop.Tags, FiltersSelection.AppliedTagFilters)
          searchFilter: Shop => when(searchText, has(Shop[name], searchText)) # Returning 'undefined' is interpreted as not filtered.

      App:
        type: ui
        nodes:
          Tabs:
            type: tree # It's used for readability, by wrapping its elements under *nodes* properties.
            nodes:
              Home:
                CustomerLocation: location, services.getCurrentLocation(CustomerLocation)

              Explore:
                searchText: plugins.autoFill(searchText)

          TabSwitcher:
              type: ui.tabSwitcher
              config:
                tabs: App.Tabs

        FiltersSelection:
          fields: # #Note: The type of the resource is inferred to be 'object' due to the existence of the property, fields.
            Tags:
              hasOffers:
                type: boolean
                value: False
              isPureVeg:
                type: boolean
                value: False # #Note: The value signifies, whether the filter is applied or not.
            AppliedTagFilters: filter(Filter.Tags, true) # #Note: The key is used for caching the function results. There is a plan to implement lazy evaluation, on functions, so that there won't be a need for explicit caching.

      ShopSelector:
        fields: # #ToDo: Implement an action.
          sortKey: [dit, avgCost, rating]
          Shops:
            type: List<Shop>
            filter: cascade(Filters.tagFilter, Filters.cuisineFilter, Filters.searchFilter)
            sortKey: sortKey

  Cart:
    providers: [shared] # #Note: This essentially is prototypal inheritance and are recursive (multi-level).
    fields:
      Shop: when(existing, confirm("Want to discard items from $existing[name] and buy from $incoming[name]?", existing, incoming)) # A Shop would be passed to the setter, for further action. #Note: The function would be called only when there's an existing value.
      id: Shop[id]
      title:
        value: Shop[name]
        scope: ui
      Articles: # #ToDo: Figure out the way to mimic the required behaviour of representing articles with different customizations as different items.
        type: list
        elementType: Article
        orderBy: Article.addedTime
        filter: Article[shop] == Cart[Shop][id]
      subTotal:
        map(Articles, Article => Article.count * Article.unitPrice)
        # SELECT Article.count * Article.unitPrice from Articles
        # sum(Articles.count * Articles.unitPrice) # In which the Articles.cost is an enumerator (like that of Python's Pandas).
      taxes: reduce(Articles, 0, (Article, trailing => trailing += Article.taxes))
      netTotal: subTotal + deliveryCharge + Taxes
      createdAt:
        value: currentTime()
        scope: store

      deliveryCharge:
        function: case
        param: Cart[subTotal]
        cases:
          param > Config[freeDeliveryMinimum] : 0
          default : Config[deliveryCharge]

  Promos: Map<Promo> # This essentially is a shorthand for Promos is a map, with Promo[id] as its mapKey.

  Promo:
    id: string
    effect: {} # Should be an effect overriding the Cart.

  Menu:
    shop: integer
    Articles: [Article...]
