---
# #Note: The structures, alike, are often represented by different syntax, so to showcase the possibilities.
imports:
  - eka.shorthands.types.* # Provides type shorthands.
  - services # #ToDo: Think of using python style "as" keyword.

declarations: # Declarations are a way to declare shorthands.
  server: customerServer

  shared:
    scope: customerApp, server # #Later: Think of inferring (implicit) scope, by identifying the object type through its properties.

  location:
    fields: # Properties defined under fields are accessible through the parent element. ie: lat could be accessed as location.lat.
      lat: double
      long: double

structure:
  Session: # Session handler is a (shared) Service. It takes care of the authentication of all requests.
    scope: shared
    fields: # #Note: The absence of the 'id' field implies that this is a create request.
      user: string
      password: password # The scope, client is implied for the type, password.

  Order: # This will query the route "/Order", no-params would be passed though, as the server knows the values. The call to create would be an update instead, if there were an Order returned from the server.
    providers: server.Order
    sync: true # This tells that, any change to the object should be synced with the server. This also is a two-way sync, so any unsubmitted order from the server would be posted to the app, on load.
    fields:
      Shop:
        filter: Incoming => when(Shop, confirm("Want to discard items from $Shop.name and buy from $Incoming.name?", Incoming)) # #Note: Filter functions on values are used as transformation hooks, any truthy value returned from such a function would be passed to the underlying setter.
      Items:
        filter: Items.Dish.Shop == Shop
        fields:
          Customizations: filter(collect(Dish.Customizations), true).name # The collect function collects the data through a generated form, based on the given schema (Dish.Customizations). When a user cancels the action, every action till the event (of adding an Item) is cancelled.

  Server:
    type: group # Groups are used to share properties across its children.
    scope: server
    children:
      Config:
        fields: {} # A global state value with multiple config variables. It's not defined, in the interest of brevity.

      Profile: {}

      promo: server.promo

      Shops:
        type: Map # #Later: The notation Map<Shop> could be used, after the implementation of DSL parsing. #Note: A map is used, not a list, as there isn't a need for keeping it ordered.
        element: server.shop # #Note: This is an implicit import from configs/server.yml.
        # The id is assumed to be the key. Alternatively, it could be map<Shop.id, Shop>.
        filter:
          scope: shared
          value: None => services.isShopWithinRadius(CustomerLocation, Config.deliveryRange) # The table shop is inferred to be iterated from the element type (shop). This also maps to the resource /Shops/{CustomerLocation}, as the server doesn't know the value (it knows Config.deliveryRange, though). The request is made again, when the CustomerLocation changes. #Note: This flow depends upon the scope of the call isShopWithinRadius limited to the server (ie: it shouldn't be available in the client).
        limit: 100
        orderBy: relevance descending

  UI:
    type: group
    scope: ui # The config is shared with all the members of the group.
    children: # Children is a property which facilitates access, but nothing more.
      CustomerLocation: location # Though the property is under the group, ui. It lives in the parent scope, as groups don't have a scope of their own.
      searchText: string

      Filters:
        children:
          tagFilter: Shop => hasMatch(Shop.Tags, FiltersSelection.AppliedTagFilters) # #Note: The function itself, should be optimized for empty lists. Variable dependency too should be taken care of.
          # cuisineFilter: Shop => hasMatch(Shop.Tags, FiltersSelection.AppliedTagFilters)
          searchFilter: Shop => when(searchText, has(Shop.name, searchText)) # Returning 'undefined' is interpreted as not filtered. #Note: The same filters could be used on the server side too.

      Shop:
        action: SelectedShop = Shop # The default action is a touch or a click.
        route: Dishes # Route to the screen, Dishes when a shop is clicked.

      Dish:
        providers: server.Dish # Providers provide the base for the object. The provided properties are overridden by customizations. There could be multiple providers (as a list) for an object.
        actions: # The scope of actions, is always, ui.
          addOrderItem:
            title: '+'
            sequence:
              - Order.Shop = Shop
              - Order.Items.add(Dish) # The added Dish is mapped to Items.Dish (through a type match). Other fields aren't passed as they are collected through the UI.
          removeOrderItem:
            children:
              matchingItem = Item => Item.Dish.id = Dish.id # #Later: The function could be automatically generated, by comparing the inline lambdas.
            title: '-'
            enabled: count(filter(Order.Items.Dish, Dish)) # When value is given for filter, other than a function, an equality check would be done.
            sequence:
              - Order.Items.remove(last(filter(Order.Items, OrderItem => OrderItem.Dish == Dish)))

      App:
        type: ui # This also implies scope: ui.
        route: MainScreen
        nodes:
          MainScreen:
            Tabs:
              # type: tree # It's used for readability, by wrapping its elements under *nodes* properties.
              # tree: {}
              nodes:
                Home:
                  nodes:
                    CustomerLocation: Global.CustomerLocation = services.getUserLocation() # The keyword, Global is used for mere demonstration.

                    FiltersSelection:
                      fields: # #Note: The type of the resource is inferred to be 'object' due to the existence of the property, fields.
                        Tags:
                          hasOffers:
                            type: boolean
                            value: False
                          isPureVeg:
                            type: boolean
                            value: False # #Note: The value signifies, whether the filter is applied or not.
                        AppliedTagFilters: filter(Filter.Tags, true) # #Note: This variable is used for caching the function results. There is a plan to implement lazy evaluation, on functions, so that there won't be a need for explicit caching.

                    Promos:
                      type: List<promo> # This essentially is a shorthand for a list of promos.
                      orderBy: weightage descending # The weightage is of the element.

                    ShopSelector:
                      fields:
                        sortOrder: rating descending, dit, avgCost
                        Shops:
                          type: List<Shop>
                          value: Shops
                          filter: cascade(Filters.tagFilter, Filters.cuisineFilter, Filters.searchFilter)
                          orderBy: sortOrder

                Explore:
                  nodes:
                    searchText:
                      value: searchText
                      handler: plugins.autoFill
                      plugins.autoFill.config: # This config is for the plugin, autoFill.
                        limit: 10

                Cart:
                  value: Order # This binds the Cart to the Order.
                  fields:
                    Items: # This overlays Order.Items
                      groupBy: Items.Dish, Items.Customizations # #Later: Indexes on groupBy columns could be auto-generated to make the calculation cycles efficient.
                      fields:
                        cost: sum(Items.cost) # All fields that aren't in groupBy should be over-rode with aggregators. #Later: Default aggregators can be provided, based on the data type of the fields. The function mode for string, sum for double etc. # #Note: Items, here, resolve to the grouped Items, not the ungroupped Items. The later could be accessed through the notation, Cart.Items.
                        count: count()

                  actions: # The scope of actions, is always, ui.
                    addOrderItem:
                      title: '+'
                      action: Order.Items.add(Dish) # The symbol Dish is resolved to Items.Dish, through cascading.
                    removeOrderItem:
                      title: '-'
                      sequence:
                        - "Order.Items.remove(last(filter(Order.Items,
                            OrderItem => OrderItem.Dish == Items.Dish && OrderItem.Customizations == Items.Customizations
                          ))"

              Account: {}

            TabSwitcher:
                type: ui.tabSwitcher
                config:
                  tabs: App.Tabs

          Dishes:
            type: List # No UI spec is given as it would be rendered as a simple, scrollable list.
            element:
              type: Dish
              filter: Dish.Shop == SelectedShop # This would query the route /Dish?Shop=<SelectedShop.id>. The filter would not apply to client actions, as they don't affect the list (values of this list are set only from the server).
