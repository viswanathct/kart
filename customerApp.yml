---
# #Note: The structures, alike, are often represented by different syntax, so to showcase the possibilities.

namespace: customerApp # When a namespace is not given, the filename is considered as the namespace.

imports:
  - eka.shorthands.types.* # Provides type shorthands.
  - services # #ToDo: Think of using python style "as" keyword.
  - customerServer
  - customerServer.*

declarations: # Declarations are a way to declare shorthands (aliases).
  server: customerServer # This is an alias, for an implicit import.

  location:
    fields: # Properties defined under fields are accessible through the parent element. ie: lat could be accessed as location.lat.
      lat: double
      long: double

structure:
  CustomerLocation: location
  searchText: string

  Filters:
    children:
      tagFilter: Shop => hasMatch(Shop.Tags, App.Home.FiltersSelection.AppliedTagFilters) # #Note: The function itself, should be optimized for empty lists. Variable dependency too should be taken care of.
      # cuisineFilter: Shop => hasMatch(Shop.Tags, FiltersSelection.AppliedTagFilters)
      searchFilter: Shop => when(searchText, has(Shop.name, searchText)) # Returning 'undefined' is interpreted as not filtered. #Note: The same filters could be used on the server side too.

  Server:
    type: group # The configuration of a group are shared by all of its members. #Note: Groups don't have a scope of their own; ie: the members of the group will live in the scope where the group is declared.
    providers: server # A namespace as a provider allows the overriding / overlaying of the members of the scope locally.
    members:
      Shop:
        action: SelectedShop = Shop # The default action is a touch or a click.
        route: Dishes # Route to the screen, Dishes when a shop is clicked.

      Dish: # The config overrides the values of server.Dish locally, as the server is the providing namespace.
        # providers: server.Dish # Providers provide the base for the object. The provided properties are overridden by customizations. There could be multiple providers (as a list) for an object.
        fields:
          taxPercentage:
            hidden: true
        actions:
          addOrderItem:
            title: '+'
            sequence:
              - Order.Shop = Shop
              - Order.Items.add(Dish) # The added Dish is mapped to Items.Dish (through a type match). Other fields aren't passed as they are collected through the UI.
          removeOrderItem:
            title: '-'
            enabled: count(filter(Order.Items.Dish, Dish)) # When value is given for filter, other than a function, an equality check would be done.
            sequence:
              - Order.Items.remove(last(filter(Order.Items, OrderItem => OrderItem.Dish == Dish)))

        Order: # This will query the route "/Order", no-params would be passed though, as the server knows the values. The call to create would be an update instead, if there were an Order returned from the server.
          sync: no-wait # This tells that, any change to the object should be synced with the server. This also is a two-way sync, so any unsubmitted order from the server would be posted to the app, on load. In case of a failed sync, the object would be restored to its prior state.
          fields: # Note: The field, User is bound th the Session, this automatically imports the Session from the server structure.
            Shop:
              filter: Incoming => when(Shop, confirm("Want to discard items from $Shop.name and buy from $Incoming.name?", Incoming)) # #Note: Filter functions on values are used as transformation hooks, any truthy value returned from such a function would be passed to the underlying setter.
            state:
              sync: wait # state change of the Order depends upon a success response from the server. #Note: Though wait, is the default option for sync, it's mentioned to override the parent config and to demonstrate.
            Items:
              filter: Items.Dish.Shop == Shop
              fields:
                Customizations: filter(collect(Dish.Customizations), true).name # The collect function collects the data through a generated form, based on the given schema (Dish.Customizations). When a user cancels the action, every action till the event (of adding an Item) is cancelled.

  App:
    type: ui
    route: MainScreen
    nodes:
      MainScreen:
        Tabs:
          # type: tree # It's used for readability, by wrapping its elements under *nodes* properties.
          # tree: {}
          nodes:
            Home:
              nodes:
                CustomerLocation: Global.CustomerLocation = services.getUserLocation() # The keyword, Global is used for mere demonstration.

                FiltersSelection:
                  fields: # #Note: The type of the resource is inferred to be 'object' due to the existence of the property, fields.
                    Tags:
                      hasOffers:
                        type: boolean
                        value: False
                      isPureVeg:
                        type: boolean
                        value: False # #Note: The value signifies, whether the filter is applied or not.
                    AppliedTagFilters: filter(Filter.Tags, true) # #Note: This variable is used for caching the function results. There is a plan to implement lazy evaluation, on functions, so that there won't be a need for explicit caching.

                Promos:
                  type: List<promo> # This essentially is a shorthand for a list of promos.
                  orderBy: weightage descending # The weightage is of the element.

                ShopSelector:
                  fields:
                    sortOrder: rating descending, dit, avgCost
                    Shops:
                      type: List<Shop>
                      value: Shops
                      filter: cascade(Filters.tagFilter, Filters.cuisineFilter, Filters.searchFilter)
                      orderBy: sortOrder

            Explore:
              nodes:
                searchText:
                  value: searchText
                  handler: plugins.autoFill
                  plugins.autoFill.config: # This config is for the plugin, autoFill.
                    limit: 10

            Cart:
              value: Order # This binds the Cart to the Order.
              fields:
                Items: # This overlays Order.Items
                  groupBy: Items.Dish, Items.Customizations # #Later: Indexes on groupBy columns could be auto-generated to make the calculation cycles efficient.
                  fields:
                    cost: sum(Items.cost) # All fields that aren't in groupBy should be over-rode with aggregators. #Later: Default aggregators can be provided, based on the data type of the fields. The function mode for string, sum for double etc. # #Note: Items, here, resolve to the grouped Items, not the ungroupped Items. The later could be accessed through the notation, Cart.Items.
                    count: count()

                actions:
                  addOrderItem:
                    title: '+'
                    action: Order.Items.add(Dish) # The symbol Dish is resolved to Items.Dish, through cascading.
                  removeOrderItem:
                    title: '-'
                    sequence:
                      - "Order.Items.remove(last(filter(Order.Items,
                          OrderItem => OrderItem.Dish == Items.Dish && OrderItem.Customizations == Items.Customizations
                        ))"

              actions:
                placeOrder:
                  title: 'Order'
                  action: Order.state = 'placed' # The Order isn't submitted, as it's synced. Any state dependent state / action would be processed once the server returns a success.

          Account: {}

        TabSwitcher:
            type: ui.tabSwitcher
            config:
              tabs: App.Tabs

      Dishes:
        type: List # No UI spec is given, so spec would be the same as the default of the handler, for such a structure.
        element:
          type: Dish
          filter: Dish.Shop == SelectedShop # This would query the route /Dish?Shop=<SelectedShop.id>. The filter would not apply to client actions, as they don't affect the list (values of this list are set only from the server).
